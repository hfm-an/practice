## 回文数

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

首先想到的肯定就是转成字符串，然后字符串 `reverse` 之后比较：

```js
// 456 ms, 11509 个测试用例
function isPalindrome (x) {
    return x.toString() === x.toString().split('').reverse().join('')
}
```

这样可以是可以，但是其实空间开销比较大。

先抛开空间复杂度来看，其实有一些使我们不需要去判断的，比如负数，比如 10 的倍数(0 除外)

所以添加了些判断：

```js
// 304 ms, 11509 个测试用例
function isPalindrome (x) {
    if (x < 0) return false
    if (x % 10 === 0 && x !== 0) return false
    return x.toString() === x.toString().split('').reverse().join('')
}
```

字符串不行的话，那我们就只能一位一位的去比较了

首先回文，我们不需要把整个数字全部颠倒过来进行比较，我们只需要比如 `123454321` 倒着取出来从末尾开始的的 `12345`，然后源数字剩下 `1234` 我们就可以进行比较了

这里需要注意的就是，末尾是 0 的时候，会影响到我们的判断，比如说 `1234543210` 的时候，末尾开始取出来第一位是 0，好在我们一开始就做了判断，对末尾是 0 的数字进行了处理

还有个问题就是，我们如何判断出是否已经到了数字的中间呢？

这个其实也简单，如果说处理后的 `x` 小于或者等于我们从末尾开始取的数字的时候，就说明我们已经走过了一半

比如：

```
123454321 => 从末尾开始取的时候，原始数字会每次 /10, 最后院士数字变成 1234, 从末尾开始取的数字变成 12345, 此时新数字是 > 源数字的
12344321 => 从末尾开始取的时候，原始数字变成 1234，新数字也是 1234， 则跳出循环
```

所以我们代码也就显而易见了：

```js
// 272 ms, 11509 个测试用例，超越了 96.43% 的 js 提交记录....
// 果然空间复杂度下去了
function isPalindrome (x) {
    if (x < 0) return false
    if (x % 10 === 0 && x !== 0) return false
    let lastIndexNum = 0

    while (x > lastIndexNum) {
        lastIndexNum = 10 * lastIndexNum + x % 10
        x = parseInt(x / 10)
    }

    return x === lastIndexNum || x === parseInt(lastIndexNum / 10)
}
```

